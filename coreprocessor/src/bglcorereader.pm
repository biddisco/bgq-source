#-*- mode: perl;-*-
# begin_generated_IBM_copyright_prolog                             
#                                                                  
# This is an automatically generated copyright prolog.             
# After initializing,  DO NOT MODIFY OR MOVE                       
# ================================================================ 
#                                                                  
# Licensed Materials - Property of IBM                             
#                                                                  
# Blue Gene/Q                                                      
#                                                                  
# (C) Copyright IBM Corp.  2007, 2011                              
#                                                                  
# US Government Users Restricted Rights -                          
# Use, duplication or disclosure restricted                        
# by GSA ADP Schedule Contract with IBM Corp.                      
#                                                                  
# This software is available to you under the                      
# Eclipse Public License (EPL).                                    
#                                                                  
# ================================================================ 
#                                                                  
# end_generated_IBM_copyright_prolog                               

package bglcorereader;

use     warnings;

require Exporter;

@ISA         = qw(Exporter);
@EXPORT      = qw();
@EXPORT_OK   = qw();
%EXPORT_TAGS = ( all => \@EXPORT_OK );
$VERSION     = v1.0;
$SVERSION    = '$Id: bglcorereader.pm,v 1.6 2008/05/19 21:38:12 mtn Exp $';
@DCRLIST=("BGL_TSDCR_RE_SND_XP",
	    "BGL_TSDCR_RE_SND_XM",
	    "BGL_TSDCR_RE_SND_YP",
	    "BGL_TSDCR_RE_SND_YM",
	    "BGL_TSDCR_RE_SND_ZP",
	    "BGL_TSDCR_RE_SND_ZM");

sub new 
{
  my ($invocant, $options) = @_;
  my ($class   ) = ref($invocant) || $invocant;
  
  my ($self) = {
      "version" => $VERSION,
      "have_refreshed" => 0,
      "options" => $options
  };
  
  $self->{"options"}{"debugionode"}      = 0;
  $self->{"options"}{"debugcomputenode"} = 1;
  
  @{$self->{"coredirs"}} = split(":", $$options{"-c"});
  $self->{"mincore"} = 0;  
  $self->{"mincore"} = $$options{"-mincore"}  if(exists $$options{"-mincore"});
  $self->{"maxcore"} = 64*2*1024;  
  $self->{"maxcore"} = $$options{"-maxcore"}  if(exists $$options{"-maxcore"});
  
  bless  ($self,$class);
  return ($self);
}

@regnames = ();
for($x=0; $x<32; $x++)
{
    push(@regnames, sprintf("r%02d", $x));
}
push(@regnames, "lr", "cr", "xer", "ctr");
push(@regnames, "msr","dear", "esr", "fpscr");
push(@regnames, "dbcr0", "dbsr");

sub readcore
{
    my($CORE, $filename) = @_;
    $id = $filename;
    
    my $data = "";
    open(TMP, $filename);
    while($line = <TMP>) { $data .= $line; };
    close(TMP);
    
    ($CORE->{$id}{signal}, $CORE->{$id}{signame}) = $data =~ /software signal\.+(\S+)\s+\((\S+)\s+/;
    ($CORE->{$id}{int}, $CORE->{$id}{intname}) = $data =~ /generated by interrupt\.+(\S+)\s+\((.*)\)/;
    
    $CORE->{$id}{"procstatus"} = "core";
    $CORE->{$id}{"kernelstatus"} = "core";
    $CORE->{$id}{"ionode"} = 0;
    
    foreach $regname (@regnames)
    {
	($CORE->{$id}{"coreregs"}{$regname}) = $data =~ /$regname=(\S+)/;
    }
    
    $CORE->{$id}{"node_accessible"} = 1;
    $CORE->{$id}{"stripframes"}     = 0;
    $CORE->{$id}{"clipthreshold"}   = 0;
    $CORE->{$id}{"corefilepath"} = $filename;
    $CORE->{$id}{"corerawdata"}  = $data;
    
    ($CORE->{$id}{"stack_start"}) = $data =~ /stack top\.+(\S+)/;
    ($CORE->{$id}{"stack_fp"})    = $data =~ /stack frame pointer\.+(\S+)/;
    ($CORE->{$id}{"heap_end"})    = $data =~ /end of heap\.+(\S+)/;
    ($CORE->{$id}{"prog_start"})  = $data =~ /start of program\.+(\S+)/;
    ($CORE->{$id}{"coreregs"}{"IAR"}) = $data =~ /while executing instruction at\.+(\S+)/;
    
    ($CORE->{$id}{"personality"}{"mpirank"}) = $filename =~ /\.(\d+)$/;
     $CORE->{"mpimap"}[$CORE->{$id}{"personality"}{"mpirank"}] = $id;
    
    my($x,$y,$z) = $data =~ /XYZ Coordinates\.+\s*(\d+),\s*(\d+),\s*(\d+)/;
    
    if(defined $x)
    {
	$CORE->{$id}{"personality"}{"x"} = $x;
	$CORE->{$id}{"personality"}{"y"} = $y;
	$CORE->{$id}{"personality"}{"z"} = $z;
    
	$CORE->{"maxx"} = $x+1 	    if($x >= $CORE->{"maxx"});
	$CORE->{"maxy"} = $y+1 	    if($y >= $CORE->{"maxy"}); 
	$CORE->{"maxz"} = $z+1 	    if($z >= $CORE->{"maxz"});
    }   
    
    foreach $dcr (@DCRLIST)
    {
	($CORE->{$id}{"dcr"}{$dcr}) = $data =~ /DCR\s+$dcr\s+=\s+(\d+)/;
    }
    
    my $fcc = 0;
    foreach $line (split("\n", $data))
    {
	$line =~ s/^\s*//;
	if($fcc)
	{
	    unshift(@{$CORE->{$id}{"stacktrace"}}, $line);
	}
	$fcc = 1 if($line =~ /function call chain:/i);
    }
}

sub start_refresh
{
    my($CORE) = @_;
    
    $CORE->{"maxx"} = 0;
    $CORE->{"maxy"} = 0;
    $CORE->{"maxz"} = 0;
    @{$CORE->{"corefiles"}} = ();
    my $numcorefiles = 0;
    foreach $coredir (@{$CORE->{"coredirs"}})
    {
	opendir(DIR, $coredir) or die "Unable to open corefile directory \"$coredir\"";
	my @files = readdir(DIR);
	closedir(DIR);
	

	foreach $file (@files)
	{
	    if($file =~ /^core\.\d+$/)
	    {
		($tag) = $file =~ /^core\.(\d+)$/;
		if(($tag >= $CORE->{"mincore"})&&($tag <= $CORE->{"maxcore"}))
		{
		    $numcorefiles++;
		    push(@{$CORE->{"corefiles"}}, "$coredir/$file");
		}
	    }
	}
    }
    if($numcorefiles == 0)
    {
	my $dirs = join(", ", @{$CORE->{"coredirs"}});
	die "Could not find any core files in the specified directories \"$dirs\"";
    }
}

sub is_refresh_inprogress
{
    my($CORE) = @_;
    return 1 if($#{@{$CORE->{"corefiles"}}}+1 > 0);
    return 0;
}

sub refresh
{
    my($CORE) = @_;
    start_refresh($CORE);
    while(is_refresh_inprogress($CORE))
    {
	readcore($CORE, shift @{$CORE->{"corefiles"}});
    }
    $CORE->{"have_refreshed"} = 1;
}

sub touchlocation
{
    my($CORE) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchiar
{
    my($CORE) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchstackdata
{
    my($CORE) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchdcr
{
    my($CORE, $dcr) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchkernelstatus
{
    my($CORE) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchregisters
{
    my($CORE) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub touchmemory
{
    my($CORE, $address) = @_;
    refresh($CORE) if($CORE->{"have_refreshed"} != 1);
}
sub setaccessmask
{
    my($CORE, $value, @nodes) = @_;
    foreach $node (keys %{$CORE})
    {
        if(($node =~ /mmcsnode_\d+/) || ($node =~ /core\.\d+$/))
	{
            $CORE->{$node}{"node_accessible"} = 1-$value;
	}
    }
    foreach $node (@nodes)
    {
	$CORE->{$node}{"node_accessible"} = $value;
    }
}


sub isaccessible
{
    my($CORE, $key) = @_;

    return 0 if(($CORE->{"options"}{"debugionode"}==0) && ($CORE->{$key}{"ionode"}==1));
    return 0 if(($CORE->{"options"}{"debugcomputenode"}==0) && ($CORE->{$key}{"ionode"}==0));
    return 0 if(! $CORE->{$key}{"node_accessible"});
    return 1;
}

sub getnodenames
{
    my($CORE, $accessible) = @_;
    my @list = ();
    foreach $key (keys %{$CORE})
    {
	if($key =~ /core\.\d+$/)
	{
	    if((!defined $accessible) || isaccessible($CORE, $key))
	    {
		push(@list, $key);
	    }
	}
    }
    return @list;
}

sub getmpiname
{
    my($CORE, $index) = @_;
    return $CORE->{"mpimap"}[$index];
}

sub getnameddcrs
{
    my($CORE) = @_;
    return @DCRLIST;
}

sub getnamedregisters
{
    my($CORE) = @_;
    return (@regnames);
}
