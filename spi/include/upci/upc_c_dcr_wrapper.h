/* begin_generated_IBM_copyright_prolog                             */
/*                                                                  */
/* This is an automatically generated copyright prolog.             */
/* After initializing,  DO NOT MODIFY OR MOVE                       */
/* ================================================================ */
/*                                                                  */
/* Licensed Materials - Property of IBM                             */
/*                                                                  */
/* Blue Gene/Q                                                      */
/*                                                                  */
/* (C) Copyright IBM Corp.  2010, 2012                              */
/*                                                                  */
/* US Government Users Restricted Rights -                          */
/* Use, duplication or disclosure restricted                        */
/* by GSA ADP Schedule Contract with IBM Corp.                      */
/*                                                                  */
/* This software is available to you under the                      */
/* Eclipse Public License (EPL).                                    */
/*                                                                  */
/* ================================================================ */
/*                                                                  */
/* end_generated_IBM_copyright_prolog                               */

#ifndef UPC_C_DCR_WRAPPER_H
#define UPC_C_DCR_WRAPPER_H

// --------------------------------------------------
// Wrapper Header for "upc_c_dcr.h" contents.
// Checked via ./checkDcrHeader.pl ../../../../../hwi/include/bqc/upc_c_dcr.h -c upc_c_dcr_wrapper.h
// Date  : Tue May  22 13:45:39 EDT 2009
// Originating File upc_c_dcr.h Checksum >>> 14540 <<<
// --------------------------------------------------

//! \addtogroup upc_spi
//@{
/**
 * \file
 *
 * \brief UPC_C DCR Wrapper
 * defines and structures to access UPC_C module
 */
//@}


#include <hwi/include/bqc/upc_c_dcr.h>
#include <hwi/include/common/compiler_support.h>

// Notes about autogenerated dcr.h contents:
//   UPC_C_DCR_base is not set.
//   dcr_support defines (like dcr_write) cannot be used.  Use ptr and structure to access instead.
//      will only use the bit definition defines.


__BEGIN_DECLS


#define UPC_C_SRAM_NUM_GROUPS               64 //!< Total number of Group IDs in the upc_c sram data
#define UPC_C_SRAM_NUM_WORDS                64*16 //!< Total number of 64 bit words in the upc_c sram data
#define UPC_C_IOSRAM_NUM_COUNTERS           64 //!< Total number of counters in the IO SRAM.
#define UPC_C_SRAM_NUM_M1GROUPS             12 //!< Total number of Group IDs in the Mode 1 counter groups
#define UPC_C_SRAM_BASE_L2_GROUP            34 //!< The starting L2 16 Counter group ID.
#define UPC_C_SRAM_BASE_MODE0_SPEC_GROUP    50 //!< The starting speculation target 16 counter group for Mode 0
#define UPC_C_SRAM_BASE_MODE1_SPEC_GROUP    20 //!< The starting speculation target 16 Counter group for Mode 1

#define ALLONES 0xFFFFFFFFFFFFFFFFULL                                //!< 64 bits worth of ones for masks.
#define MASK64_bit(b)                      (1ULL<<(63-(b)))            //!< only set given bit
#define MASK32_bit(b)                      (1ULL<<(31-(b)))            //!< only set given bit
#define MASK16_bit(b)                      (1ULL<<(15-(b)))            //!< only set given bit

#define _PACK64_  __attribute__((__packed__)) __attribute__((aligned (8)))


// Values used in interrupt control register fields to set what type of interrupt should occur.
#define UPC_C_INT_CONTROL_MASKED   0
#define UPC_C_INT_CONTROL_MACHCHK  1
#define UPC_C_INT_CONTROL_CRITICAL 2
#define UPC_C_INT_CONTROL_NONCRIT  3

#define UPC_C_INT_STATUS_MASK_L2   0x000000003FFFC000ULL   //!< Mask of upc_c int status bits which correspond to Mode 0 L2 counters
#define UPC_C_INT_ENABLE_GRP16_bit(b) (1ULL<<(63-b))       //!< bit mask of given 16 counter group  bit


//! \brief: Register: psram_data, upc_c sram data group types
//!
//! Won't use definition in dcr header - use following unions instead.
//!
//! SRAM counter data.  This union allows access in a few ways:
//!   - By 16 counter groupid - each group is 16 counter locations
//!       In mode 0, the L2 group ID = L2Slice# + 34
//!   - By 24 counter groups  - each group is 24 counters + 8 reserved counts - this matches upc_p counter locations.
//!       In mode 0, the UPC_P counter group # = the core #
//!   - By Mode 1 Group Numbers (offset to 0x400 into SRAM)
//! MMIO@=0-3FF, 0x3fdfe400000
//!
//! access method examples are:
//!   upc_c->data16.grp[2].counter[1]      (3rd 16 counter block - it's 2nd counter for core 1)
//!   upc_c->data24.grp[1].counter[1]      (2nd 24 counter block - it's 2nd counter for core 1)
//!   upc_c->datam1.grp[1].counter[1]      (2nd Mode 1 counter block of 8 counters)
struct upc_c_data_grp16_struct {
    struct {
        uint64_t counter[16];
    } grp[UPC_C_SRAM_NUM_GROUPS];
} _PACK64_;
typedef struct upc_c_data_grp16_struct upc_c_data_grp16_t;

struct upc_c_data_grp24_struct {
    struct {
        uint64_t counter[24];
        uint64_t reserved1[8];
    } grp[UPC_C_SRAM_NUM_GROUPS/2];
} _PACK64_;
typedef struct upc_c_data_grp24_struct upc_c_data_grp24_t;

struct upc_c_data_m1grp_struct {
    uint64_t reserved2[0x80];   // pad 0x80 (SRAM Addr 0x20)
    struct {
        uint64_t counter[8];
        uint64_t reserved3[8];
    } grp[UPC_C_SRAM_NUM_M1GROUPS];
} _PACK64_;
typedef struct upc_c_data_m1grp_struct upc_c_data_m1grp_t;

struct upc_c_data_m2grp_struct {
    uint64_t data[UPC_C_SRAM_NUM_WORDS];
} _PACK64_;
typedef struct upc_c_data_m2grp_struct upc_c_data_m2grp_t;


// SRAM Organization for Mode2 Trace Data  (PSRAM_MODE2_DATA explanation)
//
// 288 bits of data are written to the SRAM.
//   In mode 0 and 1, bits 64:71, 136:143, 208:215, and 280:287 are data parity bits,
//   and there wasn't any readback of them via the PSRAM_DATA registers.
//   However, in mode 2, there is no parity, and these bits contain trace data.
//   This is what drove the creation of the psram_mode2_data registers.
//
// So in mode 2, to get all 288 bits of data you would have to read 5 registers.  Let's start at address 0 for simplicity.
//
//   PSRAM_DATA reg:  Address 0: contains bits 0:63 of trace data
//                    Address 1: contains bits 72:135 of trace data
//                    Address 2: contains bits 144:207 of trace data
//                    Address 3: contains bits 216:279 of trace data
//
//   PSRAM_MODE2_DATA reg: Address 500, bits 32:63:  contains bits 64:71, 136:143, 208:215, 280:287 of trace data.
//
//   PSRAM_DATA reg addresses 4, 5, 6, 7 would go with PSRAM_MODE2_DATA reg address 501, and so on.
//
//   The 288 bits of data contains 6 x1 cycles worth of trace data (44 bits each), plus 24 bits of trigger data (4 bits per cycle)
//
//        Bits 0:87    x2 trace data (2 x1 cycles worth)
//        Bits 88:95   trigger data
//        Bits 96:183  x2 trace data (2 x1 cycles worth)
//        Bits 184:191 trigger data
//        Bits 192:279 x2 trace data (2 x1 cycles worth)
//        Bits 280:287 trigger data




//! \brief: upc_c_mmio_t MMIO Structure
struct upc_c_mmio_struct {

    //! See sram data group types above.
    union {
        upc_c_data_grp16_t data16;                           //!< MMIO@=0x000 , 0x3fdfe400000
        upc_c_data_grp24_t data24;
        upc_c_data_m1grp_t datam1;
        upc_c_data_m2grp_t datam2;
    };

    //! These are the mode 1 least significant bit counters.
    //! This is where mode1 are accumulated and then stored into SRAM once each scan cycle.
    //! There are 15 bits in the counter data.
    //! The 15th bit is a "big" overflow.
    //! These counters are reset continually as the values are accumulated in the SRAM.
    //! Note: Counters 71, 79, 87, and 95 are not implemented.
    uint64_t mode1_count[UPC_C_DCR__MODE1_COUNT_range] ;   //!< MMIO@=0x400 , 0x3fdfe402000

    uint64_t reserved1[0x0A0]                            ;

    uint64_t psram_mode2_data[UPC_C_DCR__PSRAM_MODE2_DATA_range];   //!< MMIO@=0x500 , 0x3fdfe402800

    //! IO SRAM counters for MU, PCIE, and DevBus units.
    uint64_t iosram_data[256]                            ;   //!< MMIO@=0x600 , 0x3fdfe403000  (more space than counters)

    uint64_t reserved2[0x0100]                           ;

    uint64_t c_config                                    ;   //!< Global Config Register;  MMIO@=0x800 , 0x3fdfe404000
    //! The accum_reset bit should not be active unless absolutely necessary (perhaps for an undiscovered bug later?)
    //!   It uses extra power and when reset causes accum_control reads to be inaccurate.

    //! Mode 1 Event Combine configuration
    //! Each bit controls the corresponding even mode1 local counter.
    //!   In Mode 1 - events which occur in the x1 clock domain (A2 and 9 L1P events), are sent as two bits
    //!   and counted separately.
    //! When set, events from the matching odd counter will be accumulated into the even counter.
    //!   Bits 16 to 63 map to even local counter numbers (Bit 16 to counter 0, bit 63 to counter 94).
    //!   As an example, if bit 16 is set, counter 0 will count events 0 and 1 from CCG0.
    //!   Oddcounters are not affected by this field.
    uint64_t mode1_ec_config                             ;   //!< MMIO@=0x801 , 0x3fdfe404008

    //! UPC_C Scan Ring Status
    //! Mostly this register exists for hardware debug.
    //! However, the rcv_cycle can be used to predict when a upc_c value is going to be updated,
    //! so avoid reading values while UPC_C is updating the target value.
    //! MMIO@=802, 0x3fdfe404010
    // meaning of the status values (as of 3/25/09)
    //  send_stat:
    //      constant PRING_ST_DISABLED              : std_ulogic_vector(0 to 6) := "0000001";
    //      constant PRING_ST_ENABLE_RING1          : std_ulogic_vector(0 to 6) := "0000010";
    //      constant PRING_ST_ENABLE_RING2          : std_ulogic_vector(0 to 6) := "0000100";
    //      constant PRING_ST_SEND_SYNC1            : std_ulogic_vector(0 to 6) := "0001000";
    //      constant PRING_ST_SEND_SYNC2            : std_ulogic_vector(0 to 6) := "0010000";
    //      constant PRING_ST_COUNTING              : std_ulogic_vector(0 to 6) := "0100000";
    //      constant PRING_ST_ERROR                 : std_ulogic_vector(0 to 6) := "1000000";
    //  rcv_stat:
    //      constant PRING_RCV_ST_DISABLED          : std_ulogic_vector(0 to 11) := "000000000001";
    //      constant PRING_RCV_ST_WAIT_SYNC1        : std_ulogic_vector(0 to 11) := "000000000010";
    //      constant PRING_RCV_ST_WAIT_SYNC2        : std_ulogic_vector(0 to 11) := "000000000100";
    //      constant PRING_RCV_ST_COUNTING          : std_ulogic_vector(0 to 11) := "000000001000";
    //      constant PRING_RCV_ST_WAIT_M1_PKT_START : std_ulogic_vector(0 to 11) := "000000010000";
    //      constant PRING_RCV_ST_WAIT_M1_PKT_END   : std_ulogic_vector(0 to 11) := "000000100000";
    //      constant PRING_RCV_ST_WAIT_M2_TRIGGER   : std_ulogic_vector(0 to 11) := "000001000000";
    //      constant PRING_RCV_ST_WAIT_M2_TRIGGER_WR : std_ulogic_vector(0 to 11) := "000010000000";
    //      constant PRING_RCV_ST_WAIT_M2_DONE      : std_ulogic_vector(0 to 11) := "000100000000";
    //      constant PRING_RCV_ST_M2_DONE           : std_ulogic_vector(0 to 11) := "001000000000";
    //      constant PRING_RCV_ST_M2_RUN3           : std_ulogic_vector(0 to 11) := "010000000000";
    //      constant PRING_RCV_ST_ERROR             : std_ulogic_vector(0 to 11) := "100000000000";
    uint64_t status                                      ;   //!< MMIO@=0x802 , 0x3fdfe404010


    //! UPC_C Mode 1 Counter Control 0
    //! Control events 0-31
    uint64_t mode1_counter_control0_rw                   ;   //!< MMIO@=0x803 , 0x3fdfe404018
    uint64_t mode1_counter_control0_w1s                  ;   //!< MMIO@=0x804 , 0x3fdfe404020
    uint64_t mode1_counter_control0_w1c                  ;   //!< MMIO@=0x805 , 0x3fdfe404028

    //! UPC_C Mode 1 Counter Control 1
    //! Control events 32-63
    uint64_t mode1_counter_control1_rw                   ;   //!< MMIO@=0x806 , 0x3fdfe404030
    uint64_t mode1_counter_control1_w1s                  ;   //!< MMIO@=0x807 , 0x3fdfe404038
    uint64_t mode1_counter_control1_w1c                  ;   //!< MMIO@=0x808 , 0x3fdfe404040

    //! UPC_C Mode 1 Counter Control 2
    //! Control events 64-91
    uint64_t mode1_counter_control2_rw                   ;   //!< MMIO@=0x809 , 0x3fdfe404048
    uint64_t mode1_counter_control2_w1s                  ;   //!< MMIO@=0x80a , 0x3fdfe404050
    uint64_t mode1_counter_control2_w1c                  ;   //!< MMIO@=0x80b , 0x3fdfe404058

    //! UPC_C Counter Group 16 interrupt enable
    //! 64 groups of 16 counters
    uint64_t ccg_int_en                                  ;   //!< MMIO@=0x80c , 0x3fdfe404060

    //! UPC_C Counter Group 16 interrupt enable
    //! Read either the w1c or w1s to determine if an interrupt is active.
    //! 64 groups of 16 counters
    uint64_t ccg_int_status_w1c                          ;   //!< MMIO@=0x80d , 0x3fdfe404068
    uint64_t ccg_int_status_w1s                          ;   //!< MMIO@=0x80e , 0x3fdfe404070

    //! control the accumulate engine.
    //! This register controls a one shot accumulator.
    //! The accumulation function adds counters from 1 or two source groups into a third group
    //! (each group consisting of 16 counters).
    //! There is a mask to select which of the 16 counters should be added.
    //! Caveats:
    //!   - the operation potentially has a high latency,
    //!     the "busy" bit should be polled to determine when the operation is done.
    //!   - the operation is unreliable if either source is being updated by the hardware while
    //!     the accumulation is taking place. Thus, the "wait_time" should be generated by the
    //!     software based on the "c_status:rcv_cycle", to prevent overlap.
    //!   - The destination counters must not be in extra SRAM locations for the current mode.
    //!     (not locations updated from UPC_P or L2).
    //!   - The source and dest groups are specified by SRAM address, and there are 4 counters
    //!     per address. Thus, the function allow the addition to occur aligned on any 4 counter
    //!     location.  However, we will only use this aligned on a 16 counter group.  Thus, the
    //!     lower two bits of the address should always be zero to correspond with the "grp16" counter
    //!     groups in the "sram_data" above.
    //!   - 1 source and destination can be identical (probably will be).
    //!   - There are two potential modes of waiting:
    //!     * just wait until no overlap: allows the faster average completion,
    //!       but current source counter values may be stale.
    //!     * wait till latest source update before adding: slower average latency as must wait avg of 400-470 cycles
    //!       for current scan cycle to complete.
    //!     The rcv_cycle to wait time relationship is:
    //!       ???????????????????????????????????? <<<< TBD
    //!
    uint64_t accum_control                               ;   //!< MMIO@=0x80f , 0x3fdfe404078

    //! UPC_C force parity error on each SRAM port
    //! set bad parity on any sram write that originated from the sram, for as long as the bit is set
    uint64_t error_force;            //!< priv write only.        MMIO@=0x810 , 0x3fdfe404080

    //! UPC_C Trace capture control register
    //   See Mode 2 Trigger Position and related bits in upc_c config register
    //   The trigger bit in this reg acts as a software trigger for diagnositic purposes.
    //   However, the trigger bit in UPC_P should be used instead when implementing a software
    //   trigger for real code (much faster closer to A2).
    uint64_t m2_trigger                                  ;   //!< MMIO@=0x811 , 0x3fdfe404088

    //! UPC_C Counter Start
    //   Sends sync signal to attached units (upc_p, l2, MU, PCIe, DevBus) to start or stop counting.
    //   Enable to start, disable to stop.
    //   Used when counter "sync_override" is false.
    uint64_t counter_start                               ;   //!< MMIO@=0x812 , 0x3fdfe404090

    uint64_t reserved3[0x0009]                           ;

    //! UPC_C IO ...
    uint64_t io_ccg_int_en                               ;   //!< MMIO@=0x81c , 0x3fdfe4040e0
    uint64_t io_ccg_int_status_w1c                       ;   //!< MMIO@=0x81d , 0x3fdfe4040e8
    uint64_t io_ccg_int_status_w1s                       ;   //!< MMIO@=0x81e , 0x3fdfe4040f0

    uint64_t reserved4[1]                                ;

    //! UPC_C State - different reasons for interrupts.
    //! Machinecheck, critical, and noncritical register names are misnamed.
    //! The severity of the interrupts is really interpreted by the GEA and it's software.
    //! \todo  So how do these settings really get mapped and what is the significance?
    uint64_t interrupt_state__state;        //!< write 1s  to clear MMIO@=0x820 , 0x3fdfe404100
    uint64_t interrupt_state_control_low;   //!< write priv.        MMIO@=0x821 , 0x3fdfe404108
    uint64_t interrupt_state_control_high;  //!< write priv.        MMIO@=0x822 , 0x3fdfe404110
    uint64_t interrupt_state__force;        //!< write only, priv only. MMIO@=0x823 , 0x3fdfe404118
    uint64_t interrupt_state__first;        //!< shadows state (write has no effect) MMIO@=0x824 , 0x3fdfe404120
    uint64_t interrupt_state__machinecheck; //!< shadows state (write has no effect) MMIO@=0x825 , 0x3fdfe404128
    uint64_t interrupt_state__critical;     //!< shadows state (write has no effect) MMIO@=0x826 , 0x3fdfe404130
    uint64_t interrupt_state__noncritical;  //!< shadows state (write has no effect) MMIO@=0x827 , 0x3fdfe404138

    uint64_t reserved5[0x0006]                           ;

    //! UPC_C Parity Info ??
    uint64_t upc_io_sram_parity_info                     ;   //!< MMIO@=0x82e , 0x3fdfe404170
    uint64_t upc_sram_parity_info                        ;   //!< MMIO@=0x82f , 0x3fdfe404178

    //! UPC_C Status for hardware and software type internal errors
    uint64_t interrupt_internal_error__state;        //!< write 1s  to clear  MMIO@=0x830 , 0x3fdfe404180 write 1 to clear bits
    uint64_t interrupt_internal_error_control_high;  //!< write priv.         MMIO@=0x831 , 0x3fdfe404188
    uint64_t interrupt_internal_error__force;        //!< write only, priv only.  MMIO@=0x832 , 0x3fdfe404190 (write only)
    uint64_t interrupt_internal_error__first;        //!< shadows state (write has no effect) MMIO@=0x833 , 0x3fdfe404198
    uint64_t interrupt_internal_error__machinecheck; //!< shadows state (write has no effect) MMIO@=0x834 , 0x3fdfe4041a0
    uint64_t interrupt_internal_error__critical;     //!< shadows state (write has no effect) MMIO@=0x835 , 0x3fdfe4041a8
    uint64_t interrupt_internal_error__noncritical;  //!< shadows state (write has no effect) MMIO@=0x836 , 0x3fdfe4041b0

    //! UPC_C data at time of parity error
    uint64_t interrupt_internal_error_sw_info            ;   //!< MMIO@=0x837 , 0x3fdfe4041b8
    uint64_t interrupt_internal_error_hw_info            ;   //!< MMIO@=0x838 , 0x3fdfe4041c0
    uint64_t interrupt_internal_error_data_info          ;   //!< MMIO@=0x839 , 0x3fdfe4041c8

    uint64_t reserved6[0x0006]                           ;

    //! UPC_C which error interrupt sources have caused an interrupt
    uint64_t overflow_state__state;        //!< write 1s  to clear  MMIO@=0x840 , 0x3fdfe404200 write 1 to clear bits
    uint64_t overflow_state_control_low;   //!< write priv.         MMIO@=0x841 , 0x3fdfe404208
    uint64_t overflow_state_control_high;  //!< write priv.         MMIO@=0x842 , 0x3fdfe404210
    uint64_t overflow_state__force;        //!< write only, priv only.  MMIO@=0x843 , 0x3fdfe404218 (write only)
    uint64_t overflow_state__first;        //!< shadows state (write has no effect) MMIO@=0x844 , 0x3fdfe404220
    uint64_t overflow_state__machinecheck; //!< shadows state (write has no effect) MMIO@=0x845 , 0x3fdfe404128
    uint64_t overflow_state__critical;     //!< shadows state (write has no effect) MMIO@=0x846 , 0x3fdfe404130
    uint64_t overflow_state__noncritical;  //!< shadows state (write has no effect) MMIO@=0x847 , 0x3fdfe404138

} _PACK64_;
typedef  volatile struct upc_c_mmio_struct    upc_c_mmio_t;



//! UPC_C Counter Group 16 interrupt enable or status bits based on mode, counter and core numbers
//! Use with upc_c->ccg_int_en and upc_c->ccg_int_status_?? registers.
#define UPC_C__CCG_INT__M0_bit(core_num, ctr_num)          ( core*2 + ctr_num/16 )
#define UPC_C__CCG_INT__M0_set(core_num, ctr_num)          ( 0x8000000000000000ULL >> UPC_C__CCG_INT__M0_bit(core,ctr_num))
#define UPC_C__CCG_INT__M0_insert_bit(x,core_num,ctr_num)   _BGQ_INSERT(1, UPC_C__CCG_INT__M0_bit(core,ctr_num), x, 1ULL)

#define UPC_C__CCG_INT__M1_bit(ctr_num)                    ( 8 + ctr_num/4 + (((ctr_num/64) * (ctr_num-64)) / 2) )  // use integer calcs
#define UPC_C__CCG_INT__M1_set(ctr_num)                    ( 0x8000000000000000ULL >> UPC_C__CCG_INT__M1_bit(ctr_num))
#define UPC_C__CCG_INT__M1_insert_bit(x,ctr_num)            _BGQ_INSERT(1, UPC_C__CCG_INT__M1_bit(ctr_num), x, 1ULL)


#if 1
//! Don't initialize the UPC_C interrupt control registers - this is owned by the firmware.
//! which will configure machine checks instead.

//! UPC_C HW Error interrupt defaults
#define UPC_C__INTERRUPT_STATE_CONTROL_LOW__DEFAULT  \
    ( UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__M1_OVF_set( UPC_NONCRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__IORING_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__IORING_RCV_SM_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__IO_SRAM_PERR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__UPC_P_SRAM_PERR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__ACCUM_SM_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__MMIO_SM_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__PRING_RCV_SM_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__PRING_SEND_SM_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__PRING_ERROR_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_INTERRUPT_STATE_CONTROL_LOW__DEVBUS_CTL_PERR_set( UPC_CRITICAL_INTERRUPT ) \
    )

#define UPC_C__INTERRUPT_STATE_CONTROL_HIGH__DEFAULT ( 0 )

#define UPC_C__INTERRUPT_INTERNAL_ERROR_CONTROL_HIGH__DEFAULT \
    ( UPC_C_DCR__INTERRUPT_INTERNAL_ERROR_CONTROL_HIGH__BAD_ADDRESS_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__INTERRUPT_INTERNAL_ERROR_CONTROL_HIGH__BAD_PRIV_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__INTERRUPT_INTERNAL_ERROR_CONTROL_HIGH__BAD_DATA_PARITY_set( UPC_CRITICAL_INTERRUPT ) \
    | UPC_C_DCR__INTERRUPT_INTERNAL_ERROR_CONTROL_HIGH__BAD_ADDRESS_PARITY_set( UPC_CRITICAL_INTERRUPT ) \
    )

#define UPC_C__OVERFLOW_STATE_CONTROL_LOW__DEFAULT \
    ( UPC_C_DCR__UPC_C_OVERFLOW_STATE_CONTROL_LOW__MODE2_DONE_set( UPC_NO_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_OVERFLOW_STATE_CONTROL_LOW__IO_COUNTER_OVF_set( UPC_NO_INTERRUPT ) \
    | UPC_C_DCR__UPC_C_OVERFLOW_STATE_CONTROL_LOW__PROC_COUNTER_OVF_set( UPC_NO_INTERRUPT ) \
    )

#define UPC_C__OVERFLOW_STATE_CONTROL_HIGH__DEFAULT  ( 0 )
#endif


__END_DECLS

#endif // add nothing below this line.
